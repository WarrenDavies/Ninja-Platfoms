<!DOCTYPE html>
<html>
<head>

<style>
body{
margin:0;
}

canvas {
border: solid 5px black;
position:relative;
}

#holder {
display:block;
margin: 100px auto 0 auto;
width:800px;
height:600px;
}
</style>

<script>

function init() {
document.getElementById("canvas").focus();
console.log("start");
var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
window.requestAnimationFrame = requestAnimationFrame;

// define variables
var canvas, c;
var INTERVAL = 20;

// set up canvas
canvas = document.getElementById("canvas");
canvas.width = 800;
canvas.height = 600;
c = canvas.getContext("2d");
var WIDTH = canvas.width;
var HEIGHT = canvas.height;
var keyUpHolder = 0;

// initial canvas background 
c.beginPath();
c.fillStyle = "#3399FF";
c.rect(0,0,800,600);
c.fill();
c.closePath();

var WIDTH = canvas.width;
var HEIGHT = canvas.height;
setInterval(mainDraw, INTERVAL);
var keys = [];
var keys2 = [];
var theBadGuys = [];
var thePlatforms = [];
var e = 0;
var camera = {x: 0, y: 0, w: 800, h: 600};
var tileSize = 50;


var platformCollision = true;
var onPlatform = true;
var jumping = false;
var jumped = 0;
var moveY = false;
var moveX = false;
var moved = false;
var platformCollision = false;
var theCoins = [];
var coinsCollected = 0;
var spliced = 0;
var theBullets = [];
var neonTimer = 0;
var mouse = { x: 0, y: 0, };
var sun = {
	xPosition: 300,
	yPosition: 350,
	height: 200,
	width: 200,
	sizeStart: 10,
	sizeEnd: 50,
	timer: 0.5,
}
sun.gradient = c.createRadialGradient(sun.xPosition + (sun.height / 2), sun.yPosition + (sun.width / 2), sun.sizeStart, sun.xPosition + (sun.height / 2),sun.yPosition + (sun.width / 2), sun.sizeEnd),
sun.gradient.addColorStop(0,"yellow");
sun.gradient.addColorStop(0.0035,"yellow");
sun.gradient.addColorStop(0.55,"yellow");
sun.gradient.addColorStop(0.9,"rgb(255,255,0,0)");

var sky = {
	status: {
		top: "day",
		bottom: "day",
		platform: "day",
	},
	day: {
		r: 51,
		g: 153,
		b: 255,
	},
	sunsetOrange: {
		r: 255,
		g: 165,
		b: 0,
	},
	
	sunsetPink: {
		r: 220,
		g: 127,
		b: 127,
	},
	sunsetStatus: "not set",
	night: {
		r: 19,
		g: 24,
		b: 98,
	},
	currentBottom: {
		r: 51,
		g: 153,
		b: 255,
	},
	currentTop: {
		r: 51,
		g: 153,
		b: 255,
	},
	colorStopPosition: [1,1],
}
sky.gradient = c.createLinearGradient(0,0,0,600);
sky.gradient.addColorStop(0,"lightblue");
sky.gradient.addColorStop(1,"orange");

var platformColors = {
	status: "day",
	day: {
		r: 107,
		g: 36,
		b: 0,
	},
	dayTop: {
		r: 0,
		g: 128,
		b: 0,
	},
	sunset: {
		r: 0,
		g: 0,
		b: 0,
	},
	night: {
		r: 255,
		g: 255,
		b: 255,
	},
	current: {
		r: 107,
		g: 36,
		b: 0,
	},
	currentTop: {
		r: 0,
		g: 128,
		b: 0,
	},
}


function badGuy() {
	this.x = 700;
	this.y = 1000;
	this.w = 20;
	this.h = 60;
	this.maxSpeed = 4;
	this.speed = 1;
	this.fill = 'blue';
}

function pushBadGuy(platform) {
	theBadGuys.push({
		x: thePlatforms[platform].x + (thePlatforms[platform].w / 2) - 25,
		y: thePlatforms[platform].y - 50,
		w: 50,
		h: 50,
		onPlatform: platform,
		leftLimit: thePlatforms[platform].x,
		rightLimit: thePlatforms[platform].x + thePlatforms[platform].w,
		health: 3,
		maxSpeed: 4,
		speed: 1,
		border:' red',
		fill: 'red'
	}); 
}

function multipleCoinPush(x, y, coinsToPush) {
	var distanceFromLeft = 30;
	var spacer = 50;
	for (i = x + distanceFromLeft; i < x + (spacer * 3); i += spacer) {
		theCoins.push({
			x: i,
			y: y -50,
			w: 45,
			h: 45,
			fill:'yellow',
			border:'yellow',
			borderWidth: 0
		});
	}
}



// push platforms. Might need to have separate functions to load levels later.	  
	  
// the ground
thePlatforms.push({
	x:0,
	y:830,
	w:840,
	h:400,
	type: "ground",
	location: "left",
	fill:'#6B2400',
	fillTop: 'green',
	fillTopHeight: 20,
	borderWidth: 0,
});

thePlatforms.push({
	x:0,
	y:700,
	w:200,
	h:30,
	type: "ground",
	location: "left",
	fill:'#6B2400',
	border:'#6B2400',
	fillTop: 'green',
	fillTopHeight: 10,
	borderWidth: 0,
});

thePlatforms.push({
	x:600,
	y:600,
	w:220,
	h:30,
	type: "ground",
	location: "right",
	fill:'#6B2400',
	border:'#6B2400',
	fillTop: 'green',
	fillTopHeight: 10,
	borderWidth: 0,
});

thePlatforms.push({
	x:0,
	y:400,
	w:200,
	h:30,
	type: "ground",
	location: "left",
	fill:'#6B2400',
	border:'#6B2400',
	fillTop: 'green',
	fillTopHeight: 10,
	borderWidth: 0,
});

thePlatforms.forEach(function(i, j) {
	if (j != 0) {
		multipleCoinPush(i.x, i.y, 3);
	}
});

jumpUp = new Image();
jumpUp.src = 'jumpUP.png';
    
function updateCamera() {
	camera.y = Player1.y + (Player1.h / 2) - (camera.h / 2);
}


	
	
function Player() {
	this.x = (WIDTH / 2) - 25;
	this.y = (HEIGHT / 2) - 25 + 500;
	this.w = 50;
	this.h = 50;
	this.maxSpeed = 6;
	this.speed = 0;
	this.jumpSpeed = 0;
	this.maxJumpSpeed = 6;
	this.jumpHeight = 500;
	this.momentum = 'none';
	this.fill = 'blue';
	this.onPlatform = -1;
}
var Player1 = new Player();
updateCamera();
console.log(Player1);

function clear(c) {
	c.clearRect(0, 0, WIDTH, HEIGHT);
}

function drawCoins() {
	theCoins.forEach(function(i, j){
		c.beginPath();
		c.save();
		c.fillStyle = i.fill;
		c.arc(i.x + (i.w / 2) - camera.x, i.y + (i.h / 2) - camera.y, i.w / 2, 0, 2 * Math.PI, false);
		c.fill();
		c.restore();
		c.closePath();
	});
} 

function updatePlatformColors() {
	for (var rgbCurrent in platformColors.current) {
		if (platformColors.current[rgbCurrent] > platformColors[sky.status.platform][rgbCurrent]) {
			platformColors.current[rgbCurrent] -= 1;
		}	
		if (platformColors.current[rgbCurrent] < platformColors[sky.status.platform][rgbCurrent]) {
			platformColors.current[rgbCurrent] += 1;
		}	
	}
	var topChanger;
	if (sky.status.platform === "day") {topChanger = "dayTop"}
	if (sky.status.platform === "sunset") {topChanger = sky.status.platform}
	if (sky.status.platform === "night") {topChanger = sky.status.platform}
	for (var rgbCurrent in platformColors.currentTop) {
		if (platformColors.currentTop[rgbCurrent] > platformColors[topChanger][rgbCurrent]) {
			platformColors.currentTop[rgbCurrent] -= 1;
		}	
		if (platformColors.currentTop[rgbCurrent] < platformColors[topChanger][rgbCurrent]) {
			platformColors.currentTop[rgbCurrent] += 1;
		}	
	}
}

function drawPlatforms() {
	updatePlatformColors();
	thePlatforms.forEach(function(i, j){
			if ( i.y > camera.y - 50 && i.y < camera.y + camera.h + 50) {
			c.beginPath();
			c.lineWidth = i.borderWidth;
			c.strokeStyle = i.border;
			c.fillStyle = "rgb(" + platformColors.current.r + "," + platformColors.current.g + "," + platformColors.current.b;
			if (sky.status === "sunset") {
				//c.fillStyle = "black";
				neonTimer = 0;
			}
			if (sky.status === "night") {

			}
			c.fillRect(i.x - camera.x, i.y - camera.y, i.w, i.h);
			if (i.type === "ground") {
				c.fillStyle = "rgb(" + platformColors.currentTop.r + "," + platformColors.currentTop.g + "," + platformColors.currentTop.b;
				if (sky.status === "sunset") {
					//c.fillStyle = "black";
				}
			
			if (sky.status === "night1111111111") {
				
				console.log("here");
				/* c.fillStyle = "rgb(255,105,180)";
				c.fillRect(i.x - camera.x, i.y - camera.y, i.w, i.h); */
				
				//c.globalCompositeOperation = "lighter";
				c.lineWidth = 1;
				
				if ( platformColors.current.g === platformColors.night.g) {
					if (neonTimer < 18) {
						neonTimer += 0.2;
					}
					for (k = 0; k < neonTimer; k += 2) {
					
						c.shadowBlur = 8;
						c.shadowColor = "rgb(255,105,180)";
						console.log("hereeeee " + k);
						//c.lineWidth = k * 2;
						c.fillStyle = "rgb(255,105,180,0.05)";
						//c.fillStyle = "rgb(" + platformColors.current.r + "," + platformColors.current.g + "," + platformColors.current.b + ", 0.05)";
						c.fillRect(i.x - camera.x - k, i.y - camera.y - k, i.w + (k * 2), i.h + (k * 2));
						c.shadowBlur = 0;
						
						
						//if (k === 18) { k -= 2 };
						//c.moveTo(i.x - camera.x - k, i.y - camera.y - (i.h / 2)) - 50;
						//c.lineTo(i.x - camera.x - k + i.w, i.y - camera.y - (i.h / 2)) - 50; 
						//c.stroke();
					}
				}
				c.fillStyle = "rgb(" + platformColors.current.r + "," + platformColors.current.g + "," + platformColors.current.b + ",0.9)";
				c.fillRect(i.x - camera.x, i.y - camera.y, i.w, i.h);
				c.globalCompositeOperation = "lighter";
				//c.fillStyle = "rgb(255,255,255,0.5)";
				//c.fillStyle = "rgb(255,105,180,0.05)";
				//c.fillStyle = "rgb(" + platformColors.current.r + "," + platformColors.current.g + "," + platformColors.current.b + ", 0.2)";
				//c.fillStyle = "white";
				//c.fillRect(i.x - camera.x, i.y - camera.y, i.w, i.h);
				c.shadowBlur = 0;
				
				c.globalCompositeOperation = "source-over";		
			}
			
			
			
				//c.fillRect(i.x - camera.x, i.y - camera.y, i.w, i.fillTopHeight); 
			}
			
			c.closePath();
		}
	});
}

function drawPlayer() {
	c.beginPath();
	c.save();
	c.strokeStyle = Player1.border;
	c.fillStyle = Player1.fill;
	c.lineWidth = 0;


	c.rect(Player1.x - camera.x, Player1.y - camera.y, Player1.w, Player1.h);   
	
	c.stroke();
	c.fill();
	c.restore();
	c.closePath();
}

function drawBadGuys() {
	theBadGuys.forEach(function(i,j){
		c.beginPath();
		c.save();
		c.fillStyle = i.fill;
		c.lineWidth = 0;
		c.strokeStyle = i.border;
		c.rect(i.x - camera.x, i.y - camera.y, i.w, i.h);  
		c.stroke();
		c.fill();
		c.restore();
		c.closePath();
	});
}

// collision detection routine where 2 objects have h and w
function collidesObjects(a, b) {
	return	a.x < b.x + b.w &&
			a.x + a.w > b.x &&
			a.y < b.y + b.h &&
			a.y + a.h > b.y;
}

// collision detection where w and h must be specified
function collidesSpecific(ax, ay, aw, ah, bx, by, bw, bh) {
	return  ax < bx + bw &&
			ax + aw > bx &&
			ay < by + bh &&
			ay + ah > by;
}

// collision detection between player and platforms
function checkPlatform() {
	var onPlatform = -1;
	thePlatforms.forEach ( function(i, j) {
		if (collidesSpecific(Player1.x, Player1.y + 3, Player1.w, Player1.h, i.x, i.y, i.w, i.h)) {
			onPlatform = j;
			jumped = 0;
			jumping = false;
			Player1.y = i.y - Player1.h;
			if (Player1.speed === 0) {
				if (i.x + i.w < Player1.x + (Player1.w / 2) || i.x > Player1.x + (Player1.w / 2) ) {
					Player1.fill = 'orange';
				} else {
					Player1.fill = 'blue';
				}
			}
		}
	});
	if (onPlatform > -1) {
		Player1.onPlatform = onPlatform;
		if (Player1.onPlatform >= thePlatforms.length - 3) {
			pushPlatforms();
		}
	} else {
		Player1.onPlatform = -1;
	}
}


/// jumping from first, inside that is jumping to
var platformHeightRanges = {
	left: {
		left: {
			x: 0,
			y: 200,
		},
		middle: {
			x: 300,
			y: 200,
		},
		right: {
			x: 600,
			y: 200,
		},
	},
	middle: {
		left: {
			x: 0,
			y: 200,
		},
		middle: {
			x: 300,
			y: 200,
		},
		right: {
			x: 600,
			y: 200,
		},
	},
	right: {
		left: {
			x: 0,
			y: 200,
		},
		middle: {
			x: 300,
			y: 200,
		},
		right: {
			x: 600,
			y: 200,
		},
	},
}
var g = "left";
var h = "right";
console.log(platformHeightRanges[g][h].x);

function getHeightRange() {
	var currentTopPlatformHeight = thePlatforms[thePlatforms.length - 1].y;
	var currentPlatformLocation = thePlatforms[thePlatforms.length - 1].location
	var locationChooser = Math.ceil(Math.random() * 3);
	var targetPlatformLocation;
	switch (locationChooser) {
		case 1:
			targetPlatformLocation = "left";
			break;
		case 2:
			targetPlatformLocation = "middle";
			break;	
		case 3:
			targetPlatformLocation = "right";
			break;
	}
	console.log(currentPlatformLocation);
	return { 
		x: platformHeightRanges[currentPlatformLocation][targetPlatformLocation].x,
		y: thePlatforms[thePlatforms.length - 1].y - platformHeightRanges[currentPlatformLocation][targetPlatformLocation].y,
		location: targetPlatformLocation,
	}
	
}

function pushPlatforms() {
	for (i = 0; i < 3; i++) {
		var newPlatform = getHeightRange();
		thePlatforms.push({
			x: newPlatform.x,
			y: newPlatform.y,
			w: 220,
			h: 30,
			type: "ground",
			location: newPlatform.location,
			fill: '#6B2400',
			border: '#6B2400',
			fillTop: 'green',
			fillTopHeight: 10,
			borderWidth: 0,
		});	
		if (Math.ceil(Math.random()*2) === 1) {
			multipleCoinPush(newPlatform.x, newPlatform.y, 3);
		} else {
			pushBadGuy(thePlatforms.length - 1);
		}
	}
}

function drawHUD() {
	c.fillStyle = "black";
	c.font = 'bold 28pt Calibri';
	c.fillText("Coins:" + coinsCollected, 20, 30);

}

function checkCoinCollision() {
	if (moveY === true || moveX === true) {
		for (j = theCoins.length - 1; j >= 0; j--) {
			if (collidesObjects(Player1, theCoins[j])) {
				theCoins.splice(j, 1);
				coinsCollected += 1;
			}
		}
	}
}

function createBullet(targetX, targetY, shooterX, shooterY) {
	var deltaX = targetX - shooterX;
	var deltaY = targetY - shooterY;
	var angle = Math.atan2(deltaY, deltaX);
	var xTarget = Math.cos(angle);
	var yTarget = Math.sin(angle);
	theBullets.push( { 
		originX: shooterX,
		originY: shooterY,
		x: shooterX,
		y: shooterY,
		w: 5,
		h: 5,
		power: 1,
		speed: 10,
		xTarget: xTarget,
		yTarget: yTarget,
		color: "black",
	});
}

function updateBullets() {
	theBullets.forEach(function(i, j) {
		if (i.x > WIDTH || i.x < 0 || i.y < i.originY - 1200 || i.y > i.originY + 1200) {
			theBullets.splice(j, 1);
		} 
		theBadGuys.forEach(function(k, l) {
			if (collidesObjects(i, k)) {
				k.health -= i.power;
				theBullets.splice(j, 1);
				if (k.health < 1) {
					theBadGuys.splice(l, 1);
				}
			}
		});
		thePlatforms.forEach(function(k, l) {
			if (collidesObjects(i, k)) {
				theBullets.splice(j, 1);
			}
		});
		i.x += i.xTarget * i.speed;
		i.y += i.yTarget * i.speed;
	});
}

function drawBullets() {
	c.beginPath();
	theBullets.forEach(function(i, j) {
		c.fillRect(i.x, i.y - camera.y, i.w, i.h, i.color);
	});
	if (theBullets[0]) {
		/*c.fillText(theBullets[theBullets.length - 1].x,100,100);
		c.fillText(theBullets[theBullets.length - 1].y,100,150);
		c.fillText(theBullets[theBullets.length - 1].xTarget,100,200);
		c.fillText(theBullets[theBullets.length - 1].yTarget,100,250);
		c.fillText(theBadGuys[theBadGuys.length - 1].health,100,300); */
	}
}




function updateSun() {
// sun.timer determines how fast the sun moves down the screen by incrementing the sun's y coordinate each frame
	sun.yPosition += sun.timer;
	
// if the sun is beyond y = 2000, put it back above the screen and put the size back to normal. This is basically resetting the sun. Only the top half of the gradient is set to day to give the impression of the morning breaking.
	if (sun.yPosition > 2000) {
		sun.yPosition = -300;
		sun.sizeStart = 10;
		sun.sizeEnd = 50;
		sky.gradientMidPoint = 1;
		sky.status.top = "day";
		sky.status.platform = "day";
		sky.colorStopPosition[0] = 0;
		sky.sunsetStatus = "not set";
	}

// The sun will just be coming into the screen as the bottom half of the gradient fades into the day colors. Now we're fully into the daytime
	if (sun.yPosition > -150 && sun.yPosition < 0) {
		sky.status.bottom = "day";
	}

// put the gradient start point to the bottom of the screen before reaching y = 400, which will activate the sunset. This is so the gradient can be moved upward gradually as the sun sets. Changing this will have no effect at present as both top and bottom are set to "day".
	//	if (sun.yPosition < 400 && sun.yPosition > 350 && sky.currentBottom.g > 0) {
		//sky.currentBottom.g -= 3;
	//}
	if (sun.yPosition < 400 && sun.yPosition > 490) {
		sky.colorStopPosition[0] = 1;
	}
	
// turn sunset on. Start gradually increasing the size of the sun, set the bottom half of the gradient to the sunset color, and move the gradient up the screen.
	if (sun.yPosition >= 400) {
		sky.status.platform = "sunset";
		
		if (sky.sunsetStatus != "set") {
			if (Math.floor(Math.random() * 2) === 0) {
				sky.status.bottom = "sunsetOrange";
			} else {
				sky.status.bottom = "sunsetPink";
			}
		}
			sky.sunsetStatus = "set";
			sun.sizeStart += .1;
			sun.sizeEnd += .1;
			if (sky.colorStopPosition[0] > 0.01) {
				sky.colorStopPosition[0] -= 0.01;
			}
		}
	
// darkness begins to fall 	
	if (sun.yPosition >= 800) {
		sky.status.top = "night";
	}

// darkness falls completely
	if (sun.yPosition >= 1000) {
		sky.status.bottom = "night";
		sky.status.platform = "night";
	}
console.log(sun.yPosition);
	
// update the sun object's radial gradient to reflect the above changes
	sun.gradient = c.createRadialGradient(sun.xPosition + (sun.height / 2), sun.yPosition + (sun.width / 2), sun.sizeStart, sun.xPosition + (sun.height / 2),sun.yPosition + (sun.width / 2), sun.sizeEnd);
	sun.gradient.addColorStop(0,"yellow");
	sun.gradient.addColorStop(0.55,"yellow");
	sun.gradient.addColorStop(0.9,"rgb(255,255,0,0)");
}


function updateSky() {
/// change the color of the bottom and top halves of the background gradient by changing the rgb values by 2 each frame, according to the status of the relevant sky property. The sky property is determined by the sun position in updateSun()
// bottom half
	for (var rgbCurrent in sky.currentBottom) {
		if (sky.currentBottom[rgbCurrent] > sky[sky.status.bottom][rgbCurrent]) {
			sky.currentBottom[rgbCurrent] -= 2;
		}	
		if (sky.currentBottom[rgbCurrent] < sky[sky.status.bottom][rgbCurrent]) {
			sky.currentBottom[rgbCurrent] += 2;
		}	
		if (sky.currentBottom[rgbCurrent] - sky[sky.status.bottom][rgbCurrent] === 1 || sky.currentBottom[rgbCurrent] - sky[sky.status.bottom][rgbCurrent] === -1) {
			sky.currentBottom[rgbCurrent] = sky[sky.status.bottom][rgbCurrent];
		}
	}
// top half
	for (var rgbCurrent in sky.currentTop) {
		if (sky.currentTop[rgbCurrent] > sky[sky.status.top][rgbCurrent]) {
			sky.currentTop[rgbCurrent] -= 2;
		}	
		if (sky.currentTop[rgbCurrent] < sky[sky.status.top][rgbCurrent]) {
			sky.currentTop[rgbCurrent] += 2;
		}	
		if (sky.currentTop[rgbCurrent] - sky[sky.status.top][rgbCurrent] === 1 || sky.currentTop[rgbCurrent] - sky[sky.status.top][rgbCurrent] === -1) {
			sky.currentTop[rgbCurrent] = sky[sky.status.top][rgbCurrent];
		}
	}

// now actually draw the background gradient
	sky.gradient = c.createLinearGradient(0, 0, 0, 600);
	sky.gradient.addColorStop(sky.colorStopPosition[0], "rgb(" + sky.currentTop.r + "," + sky.currentTop.g + "," + sky.currentTop.b);
	sky.gradient.addColorStop(sky.colorStopPosition[1],"rgb(" + sky.currentBottom.r + "," + sky.currentBottom.g + "," + sky.currentBottom.b);
}


function drawBackground() {
// clear canvas
	clear(c);  

//draw the sky
	c.beginPath();
	c.fillStyle = sky.gradient;
	c.rect(0 ,0, 800, 600);
	c.fill();
	
//draw the sun
	c.fillStyle = sun.gradient;
	c.rect(sun.xPosition,sun.yPosition,sun.height,sun.width);
	c.fill();
}





/////////////////////////////////////
/////////////////////////////////////
// drawing function / game loop//////
/////////////////////////////////////
/////////////////////////////////////

function mainDraw(canvas, message) {


updateSun();
updateSky();
drawBackground();





// detect player movement
playerMove();
updateCamera();

// draw player, platform, bad guys, coins

drawPlatforms();
drawPlayer();

// bullets
updateBullets();
drawBullets();

// bad guys
drawBadGuys();


// coins
drawCoins();
checkCoinCollision();
// check the player is on a platform
//checkPlatform();

drawHUD();


///////////////////////////////////////
///////////////////////////////////////
/////////End of main game loop/////////
///////////////////////////////////////
///////////////////////////////////////
  
}


// key press detection

function playerMove(){
	if (keys[65]) {
		if (Player1.speed > -Player1.maxSpeed) {
			if (Player1.speed > -3) {
				Player1.speed -= .1;
			} else {
				Player1.speed -= .3;
			}
		}
		if (Player1.speed > 0) {
			Player1.speed -= .2;
		}
	}
	
	if (keys[68]) {
		if (Player1.speed < Player1.maxSpeed) {
			if (Player1.speed < 3) {
				Player1.speed += .1;
			} else {
				Player1.speed += .3;
			}
		}
		if (Player1.speed < 0) {
			Player1.speed += .2;
		}
	}
	
	if (!keys[68] && !keys[65]) {
		if (Player1.speed > 0) {
			Player1.speed -= .1;
		}
		if (Player1.speed < 0) {
			Player1.speed += .1;
		}
	}
	
	if (Player1.speed < 0.1 && Player1.speed > -0.1) {
		Player1.speed = 0;
	}
	

	
	checkPlatform();
	
	
		// check Platform collision
	platformCollision = false;
	thePlatforms.forEach ( function(i, j) {
	if (collidesSpecific(Player1.x + Player1.speed, Player1.y - Player1.jumpSpeed, Player1.w, Player1.h, i.x, i.y, i.w, i.h)) {

			console.log("Platform Collision");
			Player1.speed = 0;
			
			if (Player1.x < i.x + i.w && Player1.x + Player1.w > i.x) {
				Player1.jumpSpeed = 0;
				jumping = false;
				platformCollision = true;
			}
		}
	
	});
		
	if (keys[87]){
		console.log(Player1.onPlatform);
		if (Player1.onPlatform > -1) {
			jumping = true;
		}
	} 
	
	if (keys[83]) {
		if (jumping) {
			jumping = false;
		}
	}
	
	if (jumping) {
		Player1.jumpSpeed = 10;
		
		if (jumped > (Player1.jumpHeight * .5)) {
			Player1.jumpSpeed = 10;
		}
		if (jumped > (Player1.jumpHeight * .7)) {
			Player1.jumpSpeed = 8;
		}
		if (jumped > (Player1.jumpHeight * .85)) {
			Player1.jumpSpeed = 6;
		}
		if (jumped > (Player1.jumpHeight * 1 )) {
			Player1.jumpSpeed = 5;
		}
		// else 
		if (jumped > (Player1.jumpHeight * 1.05 )) {
			Player1.jumpSpeed = 4;
		}
		if (jumped > (Player1.jumpHeight * 1.1 )) {
			Player1.jumpSpeed = 3;
		}
		if (jumped > (Player1.jumpHeight * 1.15 )) {
			Player1.jumpSpeed = 2;
		}
		if (jumped > (Player1.jumpHeight * 1.2 )) {
			Player1.jumpSpeed = 0;
		}
	
		
		if (jumped < Player1.jumpHeight) {
			jumped += Player1.jumpSpeed;
		} else {
			jumped += Player1.jumpSpeed;
		}
	} else {
	Player1.jumpSpeed = 0;
	}
	
	
	// now move the player
	
	
	
	
	if (Player1.onPlatform === -1 || Player1.jumpSpeed != 0) {
		moveY = true;
	} else {
		moveY = false;
	}
	//console.log (Player1.speed);
	//console.log (Player1.x < Player1.w - 100);
	
	if ( (Player1.speed < 0 && Player1.x > 0) || (Player1.speed > 0 && Player1.x < WIDTH - Player1.w) ) {
		moveX = true;
	} else {
		moveX = false;
	}
	
	if (moveX) {
		Player1.x += Player1.speed;
	}
	
	if (moveY) {
		Player1.y -= Player1.jumpSpeed;
		if (Player1.onPlatform === -1) {
			Player1.y += 4;
		}
	}
	
	return false;
}

//// move objects around camera
function moveEverything(){
	
}




// event listeners
canvas.addEventListener("keydown", function (e) {
	keys[e.keyCode] = true;
});
canvas.addEventListener("keyup", function (e) {
	keys[e.keyCode] = false;
});
canvas.addEventListener("keyup", function (e) {
	keys2[e.keyCode] = true;
	keyUpHolder = keys2[e.keyCode];
});

canvas.addEventListener('mousemove', mouseMove, true);

canvas.addEventListener("click", function() {
	createBullet(mouse.x + camera.x, mouse.y + camera.y, Player1.x + (Player1.w / 2), Player1.y + (Player1.h / 2)  );
});

// Detect mouse movement and assign to mouseX, mouseY
function mouseMove(e) {
    if (e.offsetX) {
        mouse.x = e.offsetX;
        mouse.y = e.offsetY;
    }
    else if (e.layerX) {
        mouse.x = e.layerX;
        mouse.y = e.layerY;
    }
}




} // init
</script>

</head>

<body onload="init()">
<div id = "holder">
<canvas id="canvas" width="800" height="600" tabindex='1'></canvas>
</div>
<div style="text-align:center;"><br/><br/>w = up <br/> a = left <br/> s = down<br/> d = right<br/> left shift = sprint<br/> mouse = aim<br/> left click = shoot<br/> Refresh page to play again.</div>
</body>

</html>