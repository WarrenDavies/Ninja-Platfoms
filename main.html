<!DOCTYPE html>
<html>
<head>

<style>
body{
margin:0;
}

canvas {
border: solid 5px black;
position:relative;
}

#holder {
display:block;
margin: 100px auto 0 auto;
width:800px;
height:600px;
}
</style>

<script>

// add sprites
// make bad guys harm player
// add flying / shooting bad guys
// add variation to the types of platforms
// add the spikes that follow you up
// every hundred platforms there's a speed chase
// put sun y positions that change sky status as properties in the sun object

function init() {
document.getElementById("canvas").focus();
console.log("start");
var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
window.requestAnimationFrame = requestAnimationFrame;

// define variables
var canvas, c;
var INTERVAL = 20;

// set up canvas
canvas = document.getElementById("canvas");
canvas.width = 800;
canvas.height = 600;
c = canvas.getContext("2d");
var WIDTH = canvas.width;
var HEIGHT = canvas.height;
var keyUpHolder = 0;

// initial canvas background 
c.beginPath();
c.fillStyle = "#3399FF";
c.rect(0,0,800,600);
c.fill();
c.closePath();

var WIDTH = canvas.width;
var HEIGHT = canvas.height;
setInterval(mainDraw, INTERVAL);
var keys = [];
var keys2 = [];
var theBadGuys = [];
var thePlatforms = [];
var e = 0;
var camera = {x: 0, y: 0, w: 800, h: 600};
var tileSize = 50;
const gravity = 4;

var platformCollision = true;
var onPlatform = true;
var jumping = false;
var jumped = 0;
var moveY = false;
var moveX = false;
var moved = false;
var platformCollision = false;
var theCoins = [];
var coinsCollected = 0;
var spliced = 0;
var theBullets = [];
var neonTimer = 0;
var mouse = { x: 0, y: 0, };
var sun = {
	xPosition: 300,
	yPosition: -100,
	height: 200,
	width: 200,
	sizeStart: 10,
	sizeEnd: 50,
	timer: 0.5,
}

sun.gradient = c.createRadialGradient(sun.xPosition + (sun.height / 2), sun.yPosition + (sun.width / 2), sun.sizeStart, sun.xPosition + (sun.height / 2),sun.yPosition + (sun.width / 2), sun.sizeEnd),
sun.gradient.addColorStop(0,"yellow");
sun.gradient.addColorStop(0.0035,"yellow");
sun.gradient.addColorStop(0.55,"yellow");
sun.gradient.addColorStop(0.9,"rgb(255,255,0,0)");

var sky = {
	status: {
		top: "day",
		bottom: "day",
		platform: "day",
	},
	day: {
		r: 173,
		g: 216,
		b: 230,
	},
	sunsetOrange: {
		r: 255,
		g: 165,
		b: 0,
	},
	sunsetOrange: {
		r: 255,
		g: 204,
		b: 51,
	},
	
	sunsetPink: {
		r: 220,
		g: 127,
		b: 127,
	},
	sunsetStatus: "not set",
	night: {
		r: 19,
		g: 24,
		b: 98,
	},
	currentBottom: {
		r: 51,
		g: 153,
		b: 255,
	},
	currentTop: {
		r: 51,
		g: 153,
		b: 255,
	},
	colorStopPosition: [0,1],
}
sky.gradient = c.createLinearGradient(0,0,0,600);
sky.gradient.addColorStop(0,"lightblue");
sky.gradient.addColorStop(1,"lightblue");

var platformColors = {
	status: "day",
	day: {
		r: 107,
		g: 36,
		b: 0,
	},
	dayTop: {
		r: 0,
		g: 128,
		b: 0,
	},
	sunset: {
		r: 0,
		g: 0,
		b: 0,
	},
	night: {
		r: 255,
		g: 255,
		b: 255,
	},
	current: {
		r: 107,
		g: 36,
		b: 0,
	},
	currentTop: {
		r: 0,
		g: 128,
		b: 0,
	},
}


function badGuy() {
	this.x = 700;
	this.y = 1000;
	this.w = 20;
	this.h = 60;
	this.maxSpeed = 4;
	this.speed = 1;
	this.fill = 'blue';
}

function pushBadGuy(platform) {
	theBadGuys.push({
		x: thePlatforms[platform].x + (thePlatforms[platform].w / 2) - 25,
		y: thePlatforms[platform].y - 50,
		w: 50,
		h: 50,
		onPlatform: platform,
		target: "left",
		leftLimit: thePlatforms[platform].x,
		rightLimit: thePlatforms[platform].x + thePlatforms[platform].w,
		health: 3,
		maxSpeed: 1,
		speed: 1,
		acceleration: 0.05,
		border:' red',
		fill: 'red',
		justGotHitFromAbove: false,
	}); 
}


 
function multipleCoinPush(x, y, coinsToPush) {
	var distanceFromLeft = 30;
	var spacer = 50;
	for (i = x + distanceFromLeft; i < x + (spacer * 3); i += spacer) {
		theCoins.push({
			x: i,
			y: y -50,
			w: 45,
			h: 45,
			fill:'yellow',
			border:'yellow',
			borderWidth: 0
		});
	}
}



// push platforms. Might need to have separate functions to load levels later.	  
	  
// the ground
thePlatforms.push({
	x:0,
	y:830,
	w:840,
	h:400,
	type: "ground",
	location: "left",
	fill:'#6B2400',
	fillTop: 'green',
	fillTopHeight: 20,
	borderWidth: 0,
});

thePlatforms.push({
	x:0,
	y:700,
	w:200,
	h:30,
	type: "ground",
	location: "left",
	fill:'#6B2400',
	border:'#6B2400',
	fillTop: 'green',
	fillTopHeight: 10,
	borderWidth: 0,
});

thePlatforms.push({
	x:600,
	y:600,
	w:220,
	h:30,
	type: "ground",
	location: "right",
	fill:'#6B2400',
	border:'#6B2400',
	fillTop: 'green',
	fillTopHeight: 10,
	borderWidth: 0,
});

thePlatforms.push({
	x:0,
	y:400,
	w:200,
	h:30,
	type: "ground",
	location: "left",
	fill:'#6B2400',
	border:'#6B2400',
	fillTop: 'green',
	fillTopHeight: 10,
	borderWidth: 0,
});

thePlatforms.forEach(function(i, j) {
	if (j != 0) {
		multipleCoinPush(i.x, i.y, 3);
	}
});
pushBadGuy(0);
    
function updateCamera() {
	camera.y = Player1.y + (Player1.h / 2) - (camera.h / 2);
}

function Player() {
	this.x = (WIDTH / 2) - 100;
	this.y = (HEIGHT / 2) - 25 + 500;
	this.w = (29* 1.5);
	this.h = (50 * 1.5);
	this.maxSpeed = 6;
	this.speed = 0;
	this.jumpSpeed = 0;
	this.maxJumpSpeed = 6;
	this.jumpHeight = 500;
	this.momentum = 'none';
	this.fill = 'blue';
	this.onPlatform = -1;
	this.status = "idle";
	this.reboundTimer = 0;
	this.health = 3;
	this.invincible = false;
	this.invincibleTimer = 250;
	this.invincibleTimeAfterDamage = 250;
	this.imageSizeOffset = 10;
	this.drawing = {
		idle: {
			images: [],
			switchIndex: 0,
			switchTimer: 0,
			collisionAreas: {
				w: 29,
				h: 50,
			},
		},
		run: {
			images: [],
			switchIndex: 0,
			switchTimer: 0,
			collisionAreas: {
				w: 37.6,
				h: 52,
			},
		},
		jump: {
			images: [],
			switchIndex: 0,
			switchTimer: 0,
			collisionAreas: {
				w: 50,
				h: 54,
			},
		},
	};
	this.updatePlayerImage = function() {
		this.drawing[this.status].switchTimer += 1;
		if (Player1.status === "jump") {
			if (Player1.jumpSpeed === 0) {
				this.drawing[this.status].switchIndex = 9;
			} else {
				this.drawing[this.status].switchIndex = 10 - Player1.jumpSpeed;
			}
		} else {
			if (this.drawing[this.status].switchTimer > 5) {
				this.drawing[this.status].switchIndex += 1;
				this.drawing[this.status].switchTimer = 0;
			}	
			if (this.drawing[this.status].switchIndex > (Player1.drawing[Player1.status].images.length - 1)) {
				this.drawing[this.status].switchTimer = 0;
				this.drawing[this.status].switchIndex = 0;
			}
		}
		
		
	};
}
var Player1 = new Player();
updateCamera();

function loadPlayerImages() {
	for (i = 0; i < 10; i++) {
		Player1.drawing.idle.images[i] = new Image();
		Player1.drawing.idle.images[i].src = 'images/Idle__00' + i +'.png';
	}
	for (i = 0; i < 10; i++) {
		Player1.drawing.run.images[i] = new Image();
		Player1.drawing.run.images[i].src = 'images/Run__00' + i +'.png';
	}
	for (i = 0; i < 10; i++) {
		Player1.drawing.jump.images[i] = new Image();
		Player1.drawing.jump.images[i].src = 'images/Jump__00' + i +'.png';
	}
}
loadPlayerImages();





function clear(c) {
	c.clearRect(0, 0, WIDTH, HEIGHT);
}

function drawCoins() {
	theCoins.forEach(function(i, j){
		c.beginPath();
		c.fillStyle = i.fill;
		c.arc(i.x + (i.w / 2) - camera.x, i.y + (i.h / 2) - camera.y, i.w / 2, 0, 2 * Math.PI, false);
		c.fill();
		c.closePath();
	});
} 

function updatePlatformColors() {
	for (var rgbCurrent in platformColors.current) {
		if (platformColors.current[rgbCurrent] > platformColors[sky.status.platform][rgbCurrent]) {
			platformColors.current[rgbCurrent] -= 1;
		}	
		if (platformColors.current[rgbCurrent] < platformColors[sky.status.platform][rgbCurrent]) {
			platformColors.current[rgbCurrent] += 1;
		}	
	}
	var topChanger;
	if (sky.status.platform === "day") {topChanger = "dayTop"}
	if (sky.status.platform === "sunset") {topChanger = sky.status.platform}
	if (sky.status.platform === "night") {topChanger = sky.status.platform}
	
	for (var rgbCurrent in platformColors.currentTop) {
		if (platformColors.currentTop[rgbCurrent] > platformColors[topChanger][rgbCurrent]) {
			platformColors.currentTop[rgbCurrent] -= 1;
		}	
		if (platformColors.currentTop[rgbCurrent] < platformColors[topChanger][rgbCurrent]) {
			platformColors.currentTop[rgbCurrent] += 1;
		}	
	}
}

function drawRoundCornerRect(i, cornerSize, k) {

	c.beginPath();
	c.moveTo(i.x - k + cornerSize - camera.x, i.y - camera.y - k);
	
	c.lineTo(i.x + i.w + (k) - cornerSize - camera.x, i.y - camera.y - k);
	
	c.arc(i.x + i.w + (k) - camera.x - cornerSize, i.y - camera.y - k + cornerSize, cornerSize, 1.5*Math.PI, 2 * Math.PI);
	
	c.lineTo(i.x + i.w + (k) - camera.x, i.y + i.h - camera.y - k);
	
	c.arc(i.x + i.w + (k) - camera.x - cornerSize, i.y + i.h + (k ) - camera.y - cornerSize, cornerSize, 0, 0.5 * Math.PI);
	
	c.lineTo(i.x - k + cornerSize - camera.x, i.y + i.h + (k) - camera.y)
	
	c.arc(i.x - k + cornerSize - camera.x, i.y + i.h + (k) - camera.y - cornerSize, cornerSize, 0.5 * Math.PI, 1 * Math.PI);
	
	c.lineTo(i.x - k - camera.x, i.y - camera.y - k + cornerSize);
	
	c.arc(i.x - k + cornerSize - camera.x, i.y - (k) - camera.y + cornerSize, cornerSize, 1 * Math.PI, 1.5 * Math.PI);
	//c.closePath();
	
	c.fill();
	
//c.fillRect(i.x - camera.x - k, i.y - camera.y - k, i.w + (k * 2), i.h + (k * 2));


}


function drawPlatforms() {
	updatePlatformColors();
	var platformCounter = 0;
	thePlatforms.forEach(function(i, j){
			if ( i.y > camera.y - 50 && i.y < camera.y + camera.h + 50) {
			c.beginPath();
			c.lineWidth = i.borderWidth;
			c.strokeStyle = i.border;
			c.fillStyle = "rgb(" + platformColors.current.r + "," + platformColors.current.g + "," + platformColors.current.b;
			if (sky.status === "sunset") {
				neonTimer = 0;
			}
			c.fillRect(i.x - camera.x, i.y - camera.y, i.w, i.h);
			if (i.type === "ground") {
				c.fillStyle = "rgb(" + platformColors.currentTop.r + "," + platformColors.currentTop.g + "," + platformColors.currentTop.b;
				if (sky.status.platform === "night") {
					c.lineWidth = 1;
					if ( platformColors.current.g === platformColors.night.g) {
						if (sun.yPosition > 1495 && neonTimer > 0) {
							neonTimer -= 0.2;
						} else if (neonTimer < 18) {
							neonTimer += 0.2;
						}
						for (k = 0; k < neonTimer; k += 3) {
							c.shadowBlur = 4;
							c.shadowColor = "rgb(255,105,180)";
							c.fillStyle = "rgb(255,105,180,0.05)";
							drawRoundCornerRect(i, 20, k);
							c.shadowBlur = 0;
						}
					}
					c.lineWidth = 0;
					c.fillStyle = "rgb(" + platformColors.current.r + "," + platformColors.current.g + "," + platformColors.current.b + ",0.9)";
					c.fillRect(i.x - camera.x, i.y - camera.y, i.w, i.h);
					c.globalCompositeOperation = "lighter";
					c.shadowBlur = 0;
					c.globalCompositeOperation = "source-over";
				}
			}
			c.closePath();
			platformCounter++;
		}
	});
}

function drawPlayer() {
	c.beginPath();
	
	c.strokeStyle = Player1.border;
	c.fillStyle = Player1.fill;
	c.lineWidth = 1;

	
	c.rect(Player1.x - camera.x, Player1.y - camera.y, Player1.w, Player1.h);
	c.stroke();	
	
	console.log(Player1.drawing[Player1.status].images[Player1.drawing[Player1.status].switchIndex]);
	
	console.log(Player1.drawing[Player1.status].switchIndex);
	//c.drawImage(Player1.drawing[Player1.status].images[0], Player1.x - camera.x, Player1.y - camera.y, Player1.w, Player1.h);
	
	c.drawImage(Player1.drawing[Player1.status].images[Player1.drawing[Player1.status].switchIndex], Player1.x - camera.x - Player1.imageSizeOffset, Player1.y - camera.y - Player1.imageSizeOffset, Player1.w + (Player1.imageSizeOffset + 2), Player1.h + (Player1.imageSizeOffset));
	
	
	
	c.closePath();
}

function updateBadGuys() {
	theBadGuys.forEach(function(i,j){
		if (i.speed < i.maxSpeed) {
			i.speed += i.acceleration;
		}
		if (i.target === "left") {
			var badGuySpeed = -i.speed;
		} else {
			var badGuySpeed = i.speed;
		}
		if (i.justGotHitFromAbove === false) {
			if (collidesSpecific(i.x + badGuySpeed, i.y, i.w, i.h, Player1.x, Player1.y, Player1.w, Player1.h)) {
				console.log("updateBadGuy");
				console.log (i.y + ", " + (Player1.y + Player1.h));
				Player1.speed += (badGuySpeed * 3);
				i.speed = -(i.speed);
				if (Player1.invincible === false) {
					Player1.health -= 1;
					Player1.invincible = true;
				}
			}
		}
		if (i.justGotHitFromAbove === true) {
			i.justGotHitFromAbove = false;
		}
		if (i.target === "left") {
			if (i.x > i.leftLimit) {
				i.x -= i.speed;
			}
			if (i.x <= i.leftLimit) {
				i.target = "right";
			}
		}
		if (i.target === "right") {
			if (i.x + i.w < i.rightLimit) {
				i.x += i.speed;
			}
			if (i.x + i.w >= i.rightLimit) {
				i.target = "left";
			}			
		}	
	});
}
function drawBadGuys() {
	theBadGuys.forEach(function(i,j){
		c.beginPath();
		c.fillStyle = i.fill;
		c.lineWidth = 0;
		c.rect(i.x - camera.x, i.y - camera.y, i.w, i.h);  
		c.fill();
		c.closePath();
	});
}

// collision detection routine where 2 objects have h and w
function collidesObjects(a, b) {
	return	a.x < b.x + b.w &&
			a.x + a.w > b.x &&
			a.y < b.y + b.h &&
			a.y + a.h > b.y;
}

// collision detection where w and h must be specified
function collidesSpecific(ax, ay, aw, ah, bx, by, bw, bh) {
	return  ax < bx + bw &&
			ax + aw > bx &&
			ay < by + bh &&
			ay + ah > by;
}

// collision detection between player and platforms
function checkPlatform() {
	var onPlatform = -1;
	thePlatforms.forEach ( function(i, j) {
		if (collidesSpecific(Player1.x, Player1.y + 3, Player1.w, Player1.h, i.x, i.y, i.w, i.h)) {
			onPlatform = j;
			jumped = 0;
			jumping = false;
			Player1.y = i.y - Player1.h;
			if (Player1.speed === 0) {
				if (i.x + i.w < Player1.x + (Player1.w / 2) || i.x > Player1.x + (Player1.w / 2) ) {
					Player1.fill = 'orange';
				} else {
					Player1.fill = 'blue';
				}
			}
		}
	});
	if (onPlatform > -1) {
		Player1.onPlatform = onPlatform;
		if (Player1.onPlatform >= thePlatforms.length - 3) {
			pushPlatforms();
		}
	} else {
		Player1.onPlatform = -1;
	}
}


/// jumping from first, inside that is jumping to
var platformHeightRanges = {
	left: {
		left: {
			x: 0,
			y: 200,
		},
		middle: {
			x: 300,
			y: 200,
		},
		right: {
			x: 600,
			y: 200,
		},
	},
	middle: {
		left: {
			x: 0,
			y: 200,
		},
		middle: {
			x: 300,
			y: 200,
		},
		right: {
			x: 600,
			y: 200,
		},
	},
	right: {
		left: {
			x: 0,
			y: 200,
		},
		middle: {
			x: 300,
			y: 200,
		},
		right: {
			x: 600,
			y: 200,
		},
	},
}
var g = "left";
var h = "right";
console.log(platformHeightRanges[g][h].x);

function getHeightRange() {
	var currentTopPlatformHeight = thePlatforms[thePlatforms.length - 1].y;
	var currentPlatformLocation = thePlatforms[thePlatforms.length - 1].location
	var locationChooser = Math.ceil(Math.random() * 3);
	var targetPlatformLocation;
	switch (locationChooser) {
		case 1:
			targetPlatformLocation = "left";
			break;
		case 2:
			targetPlatformLocation = "middle";
			break;	
		case 3:
			targetPlatformLocation = "right";
			break;
	}
	console.log(currentPlatformLocation);
	return { 
		x: platformHeightRanges[currentPlatformLocation][targetPlatformLocation].x,
		y: thePlatforms[thePlatforms.length - 1].y - platformHeightRanges[currentPlatformLocation][targetPlatformLocation].y,
		location: targetPlatformLocation,
	}
	
}

function pushPlatforms() {
	for (i = 0; i < 3; i++) {
		var newPlatform = getHeightRange();
		thePlatforms.push({
			x: newPlatform.x,
			y: newPlatform.y,
			w: 220,
			h: 30,
			type: "ground",
			location: newPlatform.location,
			fill: '#6B2400',
			border: '#6B2400',
			fillTop: 'green',
			fillTopHeight: 10,
			borderWidth: 0,
		});	
		if (Math.ceil(Math.random()*2) === 1) {
			multipleCoinPush(newPlatform.x, newPlatform.y, 3);
		} else {
			pushBadGuy(thePlatforms.length - 1);
		}
	}
}

function drawHUD() {
	c.fillStyle = "rgb(" + platformColors.currentTop.r + "," + platformColors.currentTop.g + "," + platformColors.currentTop.b;
	c.font = 'bold 28pt Calibri';
	c.fillText("Coins:" + coinsCollected, 20, 30);

}

function checkCoinCollision() {
	if (moveY === true || moveX === true) {
		for (j = theCoins.length - 1; j >= 0; j--) {
			if (collidesObjects(Player1, theCoins[j])) {
				theCoins.splice(j, 1);
				coinsCollected += 1;
			}
		}
	}
}

function createBullet(targetX, targetY, shooterX, shooterY) {
	var deltaX = targetX - shooterX;
	var deltaY = targetY - shooterY;
	var angle = Math.atan2(deltaY, deltaX);
	var xTarget = Math.cos(angle);
	var yTarget = Math.sin(angle);
	theBullets.push( { 
		originX: shooterX,
		originY: shooterY,
		x: shooterX,
		y: shooterY,
		w: 5,
		h: 5,
		power: 1,
		speed: 10,
		xTarget: xTarget,
		yTarget: yTarget,
		color: "black",
	});
}

function updateBullets() {
	theBullets.forEach(function(i, j) {
		if (i.x > WIDTH || i.x < 0 || i.y < i.originY - 1200 || i.y > i.originY + 1200) {
			theBullets.splice(j, 1);
		} 
		theBadGuys.forEach(function(k, l) {
			if (collidesObjects(i, k)) {
				k.health -= i.power;
				theBullets.splice(j, 1);
				if (k.health < 1) {
					theBadGuys.splice(l, 1);
				}
			}
		});
		thePlatforms.forEach(function(k, l) {
			if (collidesObjects(i, k)) {
				theBullets.splice(j, 1);
			}
		});
		i.x += i.xTarget * i.speed;
		i.y += i.yTarget * i.speed;
	});
}

function drawBullets() {
	c.beginPath();
	theBullets.forEach(function(i, j) {
		c.fillRect(i.x, i.y - camera.y, i.w, i.h, i.color);
	});
	if (theBullets[0]) {
		/*c.fillText(theBullets[theBullets.length - 1].x,100,100);
		c.fillText(theBullets[theBullets.length - 1].y,100,150);
		c.fillText(theBullets[theBullets.length - 1].xTarget,100,200);
		c.fillText(theBullets[theBullets.length - 1].yTarget,100,250);
		c.fillText(theBadGuys[theBadGuys.length - 1].health,100,300); */
	}
}




function updateSun() {
// sun.timer determines how fast the sun moves down the screen by incrementing the sun's y coordinate each frame
	sun.yPosition += sun.timer;
	
// if the sun is beyond y = 2000, put it back above the screen and put the size back to normal. This is basically resetting the sun. Only the top half of the gradient is set to day to give the impression of the morning breaking.
	if (sun.yPosition > 1500) {
		sun.yPosition = -300;
		sun.sizeStart = 10;
		sun.sizeEnd = 50;
		sky.gradientMidPoint = 1;
		sky.status.top = "day";
		sky.status.platform = "day";
		sky.colorStopPosition[0] = 0;
		sky.sunsetStatus = "not set";
	}

// The sun will just be coming into the screen as the bottom half of the gradient fades into the day colors. Now we're fully into the daytime
	if (sun.yPosition > -150 && sun.yPosition < 0) {
		sky.status.bottom = "day";
	}

// put the gradient start point to the bottom of the screen before reaching y = 400, which will activate the sunset. This is so the gradient can be moved upward gradually as the sun sets. Changing this will have no effect at present as both top and bottom are set to "day".
	if (sun.yPosition < 400 && sun.yPosition > 390) {
		//sky.colorStopPosition[0] = 1;
	}
	
// turn sunset on. Start gradually increasing the size of the sun, set the bottom half of the gradient to the sunset color
	if (sun.yPosition >= 400) {
		sky.status.platform = "sunset";
// choose a pink or orange sunset		
		if (sky.sunsetStatus != "set") {
			if (Math.floor(Math.random() * 2) === 0) {
				sky.status.bottom = "sunsetOrange";
			} else {
				sky.status.bottom = "sunsetPink";
			}
		}
			sky.sunsetStatus = "set";
			sun.sizeStart += .1;
			sun.sizeEnd += .1;
		}
	
	if (sun.yPosition >= 600) {
		sky.status.top = sky.status.bottom;	
	}
	
// darkness begins to fall 	
	if (sun.yPosition >= 700) {
		sky.status.top = "night";
	}

// darkness falls completely
	if (sun.yPosition >= 800) {
		sky.status.bottom = "night";
		sky.status.platform = "night";
	}
//console.log(sun.yPosition);
	
// update the sun object's radial gradient to reflect the above changes
	sun.gradient = c.createRadialGradient(sun.xPosition + (sun.height / 2), sun.yPosition + (sun.width / 2), sun.sizeStart, sun.xPosition + (sun.height / 2),sun.yPosition + (sun.width / 2), sun.sizeEnd);
	sun.gradient.addColorStop(0,"yellow");
	sun.gradient.addColorStop(0.55,"yellow");
	sun.gradient.addColorStop(0.9,"rgb(255,255,0,0)");
}


function updateSky() {
/// change the color of the bottom and top halves of the background gradient by changing the rgb values by 2 each frame, according to the status of the relevant sky property. The sky property is determined by the sun position in updateSun()
// bottom half
	for (var rgbCurrent in sky.currentBottom) {
		if (sky.currentBottom[rgbCurrent] > sky[sky.status.bottom][rgbCurrent]) {
			sky.currentBottom[rgbCurrent] -= 1;
		}	
		if (sky.currentBottom[rgbCurrent] < sky[sky.status.bottom][rgbCurrent]) {
			sky.currentBottom[rgbCurrent] += 1;
		}	
		if (sky.currentBottom[rgbCurrent] - sky[sky.status.bottom][rgbCurrent] === 1 || sky.currentBottom[rgbCurrent] - sky[sky.status.bottom][rgbCurrent] === -1) {
			sky.currentBottom[rgbCurrent] = sky[sky.status.bottom][rgbCurrent];
		}
	}
// top half
	for (var rgbCurrent in sky.currentTop) {
		if (sky.currentTop[rgbCurrent] > sky[sky.status.top][rgbCurrent]) {
			sky.currentTop[rgbCurrent] -= 1;
		}	
		if (sky.currentTop[rgbCurrent] < sky[sky.status.top][rgbCurrent]) {
			sky.currentTop[rgbCurrent] += 1;
		}	
		if (sky.currentTop[rgbCurrent] - sky[sky.status.top][rgbCurrent] === 1 || sky.currentTop[rgbCurrent] - sky[sky.status.top][rgbCurrent] === -1) {
			sky.currentTop[rgbCurrent] = sky[sky.status.top][rgbCurrent];
		}
	}

// now actually draw the background gradient
	sky.gradient = c.createLinearGradient(0, 0, 0, 600);
	sky.gradient.addColorStop(sky.colorStopPosition[0], "rgb(" + sky.currentTop.r + "," + sky.currentTop.g + "," + sky.currentTop.b);
	sky.gradient.addColorStop(sky.colorStopPosition[1],"rgb(" + sky.currentBottom.r + "," + sky.currentBottom.g + "," + sky.currentBottom.b);
}


function drawBackground() {
// clear canvas
	clear(c);  

//draw the sky
	c.beginPath();
	c.fillStyle = sky.gradient;
	c.rect(0 ,0, 800, 600);
	c.fill();
	
//draw the sun
	c.fillStyle = sun.gradient;
	c.rect(sun.xPosition,sun.yPosition,sun.height,sun.width);
	c.fill();
}





/////////////////////////////////////
/////////////////////////////////////
// drawing function / game loop//////
/////////////////////////////////////
/////////////////////////////////////
var time = new Date();
var counter = 49;
var timeAtStart;
var timeAtEnd;
var timeTaken;

console.log("##### start #####");
function mainDraw(canvas, message) {
/*
counter++
if (counter === 50) {
	counter = 0;
	var time = new Date();
	timeAtEnd = time.getTime();
	timeTaken = timeAtEnd - timeAtStart;
	console.log("this loop of 50 frames took: " + timeTaken + "ms");
	time = new Date();
	timeAtStart = time.getTime();
}
*/

updateSun();
updateSky();
drawBackground();


// detect player movement
updatePlayer();
updateCamera();
updateBullets();
updateBadGuys();

drawPlatforms();
drawCoins();
drawBullets();
drawBadGuys();
drawPlayer();

// coins

checkCoinCollision();
// check the player is on a platform
//checkPlatform();

drawHUD();


///////////////////////////////////////
///////////////////////////////////////
/////////End of main game loop/////////
///////////////////////////////////////
///////////////////////////////////////
  
}


// key press detection

function updatePlayer(){
	
	Player1.updatePlayerImage();
	
	if (Player1.invincible === true) {
		Player1.invincibleTimer -= 1;
		c.fillText(100,100,Player1.invincibleTimer);
		c.fill();
		if (Player1.invincibleTimer === 0) {
			Player1.invincible = false;
			Player1.invincibleTimer = Player1.invincibleTimeAfterDamage;
		}
	}
	
	
	
	if (keys[65]) {
		if (Player1.speed > -Player1.maxSpeed) {
			if (Player1.speed > -3) {
				Player1.speed -= .1;
			} else {
				Player1.speed -= .3;
			}
		}
		if (Player1.speed > 0) {
			Player1.speed -= .2;
		}
	}
	
	if (keys[68]) {
		if (Player1.speed < Player1.maxSpeed) {
			if (Player1.speed < 3) {
				Player1.speed += .1;
			} else {
				Player1.speed += .3;
			}
		}
		if (Player1.speed < 0) {
			Player1.speed += .2;
		}
	}
	
	if (!keys[68] && !keys[65]) {
		if (Player1.speed > 0) {
			Player1.speed -= .1;
		}
		if (Player1.speed < 0) {
			Player1.speed += .1;
		}
	}
	
	if (Player1.speed < 0.1 && Player1.speed > -0.1) {
		Player1.speed = 0;
	}
	

	
	checkPlatform();
	
	
		// check Platform collision
	platformCollision = false;
	thePlatforms.forEach ( function(i, j) {
	if (collidesSpecific(Player1.x + Player1.speed, Player1.y - Player1.jumpSpeed, Player1.w, Player1.h, i.x, i.y, i.w, i.h)) {

			console.log("Platform Collision");
			Player1.speed = 0;
			
			if (Player1.x < i.x + i.w && Player1.x + Player1.w > i.x) {
				Player1.jumpSpeed = 0;
				jumping = false;
				platformCollision = true;
			}
		}
	
	});
		
	if (keys[87]){
		if (Player1.onPlatform > -1) {
			jumping = true;
			Player1.status = "jump";
		}
	} 
	
	if (keys[83]) {
		if (jumping && Player1.status != "rebound") {
			jumping = false;
		}
	}
	
	if (jumping) {
		Player1.jumpSpeed = 10;
		
		if (jumped > (Player1.jumpHeight * .5)) {
			Player1.jumpSpeed = 10;
		}
		if (jumped > (Player1.jumpHeight * .7)) {
			Player1.jumpSpeed = 8;
		}
		if (jumped > (Player1.jumpHeight * .85)) {
			Player1.jumpSpeed = 6;
		}
		if (jumped > (Player1.jumpHeight * 1 )) {
			Player1.jumpSpeed = 5;
		}
		if (jumped > (Player1.jumpHeight * 1.05 )) {
			Player1.jumpSpeed = 4;
		}
		if (jumped > (Player1.jumpHeight * 1.1 )) {
			Player1.jumpSpeed = 3;
		}
		if (jumped > (Player1.jumpHeight * 1.15 )) {
			Player1.jumpSpeed = 2;
		}
		if (jumped > (Player1.jumpHeight * 1.2 )) {
			Player1.jumpSpeed = 0;
		}
	
		
		if (jumped < Player1.jumpHeight) {
			jumped += Player1.jumpSpeed;
		} else {
			jumped += Player1.jumpSpeed;
		}
	} else {
	Player1.jumpSpeed = 0;
	}
	
	
	// now move the player
	
	
	
	
	if (Player1.onPlatform === -1 || Player1.jumpSpeed != 0) {
		moveY = true;
	} else {
		moveY = false;
	}
	//console.log (Player1.speed);
	//console.log (Player1.x < Player1.w - 100);
	
	if ( (Player1.speed < 0 && Player1.x > 0) || (Player1.speed > 0 && Player1.x < WIDTH - Player1.w) ) {
		moveX = true;
	} else {
		moveX = false;
	}
	
	if (moveX || moveY) {
		theBadGuys.forEach(function(i,j) {
			if (collidesSpecific(Player1.x + (Player1.speed * 2), Player1.y - Player1.jumpSpeed + gravity + 1, Player1.w, Player1.h, i.x, i.y, i.w, i.h)) {
				if (Player1.y + Player1.h < i.y) {
					console.log("updatePlayer: bad guy top collision " + (Player1.jumpSpeed - gravity));
					console.log(i.y + ", " + (Player1.y + Player1.h));
					Player1.y -= (Player1.jumpSpeed + 8);
					Player1.jumpSpeed = 8;
					jumping = true;
					Player1.status = "rebound";
					jumped = Player1.jumpHeight * .75;
					i.speed = 0;
					i.justGotHitFromAbove = true;
					//i.health -= 1;
					if (i.health <= 0) {
						theBadGuys.splice(j, 1);
					}
					
				}
				console.log (i.justGotHitFromAbove);
				if (i.justGotHitFromAbove === false) {
					if (Player1.x + 1 > i.x + i.w || Player1.x + Player1.w - 1 < i.x) {
						console.log("bad guy side collision");
						Player1.x = Player1.x + -(Player1.speed * 3);
						Player1.speed = -(Player1.speed / 2);
						i.speed = 0;
					}
				}
			}
		});
	}
	
	
	if (moveX) {
		Player1.x += Player1.speed;
	}
	
	if (moveY) {
		Player1.y -= Player1.jumpSpeed;
		if (Player1.onPlatform === -1) {
			Player1.y += gravity;
		}
	}
	
	if (Player1.status === "rebound") {
		Player1.reboundTimer += 1;
		if (Player1.reboundTimer > 50) {
			Player1.status = "jump";
			jumping = true;
			Player1.reboundTimer = 0;
		}
	}
	
	if (!jumping && Player1.speed === 0) {
		Player1.status = "idle";
		Player1.w = Player1.drawing.idle.collisionAreas.w * 1.5;
		Player1.h = Player1.drawing.idle.collisionAreas.h * 1.5;
	}
	if (Player1.onPlatform > -1 && Player1.speed != 0) {
		Player1.status = "run";
		Player1.w = Player1.drawing.run.collisionAreas.w * 1.5;
		Player1.h = Player1.drawing.run.collisionAreas.h * 1.5;
	}
	if (Player1.onPlatform === -1 || jumping) {
		Player1.status = "jump";
		Player1.w = Player1.drawing.run.collisionAreas.w * 1.5;
		Player1.h = Player1.drawing.run.collisionAreas.h * 1.5;
	}
	
	
	return false;
}

//// move objects around camera
function moveEverything(){
	
}




// event listeners
canvas.addEventListener("keydown", function (e) {
	keys[e.keyCode] = true;
});
canvas.addEventListener("keyup", function (e) {
	keys[e.keyCode] = false;
});
canvas.addEventListener("keyup", function (e) {
	keys2[e.keyCode] = true;
	keyUpHolder = keys2[e.keyCode];
});

canvas.addEventListener('mousemove', mouseMove, true);

canvas.addEventListener("click", function() {
	createBullet(mouse.x + camera.x, mouse.y + camera.y, Player1.x + (Player1.w / 2), Player1.y + (Player1.h / 2)  );
});

// Detect mouse movement and assign to mouseX, mouseY
function mouseMove(e) {
    if (e.offsetX) {
        mouse.x = e.offsetX;
        mouse.y = e.offsetY;
    }
    else if (e.layerX) {
        mouse.x = e.layerX;
        mouse.y = e.layerY;
    }
}




} // init
</script>

</head>

<body onload="init()">
<div id = "holder">
<canvas id="canvas" width="800" height="600" tabindex='1'></canvas>
</div>
<div style="text-align:center;"><br/><br/>w = up <br/> a = left <br/> s = down<br/> d = right<br/> left shift = sprint<br/> mouse = aim<br/> left click = shoot<br/> Refresh page to play again.</div>
</body>

</html>